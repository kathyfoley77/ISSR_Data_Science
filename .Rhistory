if(length(indexes) > 0){
text <- text[-indexes]
}
# Loop through the lines in the text and use the append() function to
clean_text <- Clean_String(text[1])
for(i in 2:length(text)){
# add them to a vector
clean_text <- append(clean_text,Clean_String(text[i]))
}
num_tok <- length(clean_text)
num_uniq <- length(unique(clean_text))
to_return <- list(num_tokens = num_tok, unique_tokens = num_uniq, text = clean_text)
}
# Calculate the number of tokens and unique tokens and return them in a
# named list object.
return(to_return)
}
#' run on all bills
clean_bill_text <- vector(mode = "list",length = 100)
for(i in 1:100){
print(i)
clean_bill_text[[i]] <- Clean_Text_Block(bill.text.list[[i]]$text)
}
#' calculate: total_token_count, total_unique_words
total_token_count <- 0
all_tokens <- NULL
for(i in 1:100){
print(i)
#keep appending the tokens to a giant vector
all_tokens <- append(all_tokens,clean_bill_text[[i]]$text)
total_token_count <- total_token_count + clean_bill_text[[i]]$num_tokens
}
# get unique words
unique_words <- unique(all_tokens)
total_unique_words <- length(unique_words)
cat("There were a total of",total_token_count,"tokens used in all documents and the number of unique words is:",total_unique_words," \n" )
wordcount<- function(word){
tally <-0
for(i in 1:100) {
if (grepl(word, clean_bill_text[[i]]$text)) {
tally<- (tally+1)
}
}
return(tally)
}
wordcount(word = "policy")
wordcount<- function(word){
for(i in 1:100) {
tally <- str_count(clean_bill_text[[i]]$text, word)
}
return(tally)
}
wordcount(word = "policy")
library(stringr)
wordcount<- function(word){
for(i in 1:100) {
tally <- str_count(clean_bill_text[[i]]$text, word)
}
return(tally)
}
wordcount(word = "policy")
add<- function(arg1, arg2){
result<- arg1 + arg2
return(result)
}
add(274, 1098)
add<- function(arg1, arg2){
result<- arg1 + arg2
return(arg1, arg2,result)
}
add(274, 1098)
add<- function(arg1, arg2){
result<- arg1 + arg2
return(arg1)
return(arg2)
return(result)
}
add(274, 1098)
add<- function(arg1, arg2){
result<- arg1 + arg2
result_list<- list(arg1, arg2, result)
return(result_list)
}
add(274, 1098)
add<- function(arg1, arg2){
result<- arg1 + arg2
result_list<- list(arg1, arg2, result)
cat(result_list)
}
add(274, 1098)
add<- function(arg1, arg2){
result<- arg1 + arg2
result_list<- list(arg1, arg2, result)
print(result_list)
}
add(274, 1098)
rm(list=ls())
source('~/GitHub/ISSR_Data_Science/scripts/day 2 in class -- advanced data management.R')
source('~/GitHub/ISSR_Data_Science/scripts/day 2 in class -- advanced data management.R')
source('~/GitHub/ISSR_Data_Science/scripts/day 2 in class -- advanced data management.R')
for (i in 1:10) {
print(i)
}
my_vect <- rep(0,100)
my_vec[60]<- 1
my_vect <- rep(0,100)
my_vect[60]<- 1
for (i in 1: lenght(my_vect){
if (my_vect[i] >0){
print(i)
}
}
for (i in 1: lenght(my_vect)){
if (my_vect[i] >0){
print(i)
}
}
for (i in 1: length(my_vect)){
if (my_vect[i] >0){
print(i)
}
}
install.packages("reshape")
library(reshape)
sum
which()
which
mean
a>1
"a">1
"b">1
"z">1
1>"q"
# Packages:
require(doMC)
require(foreach)
# Register number of cores on your computer
nCores <- 8
registerDoMC(nCores)
# iterations
N <- 100
# Run analysis in serial
system.time({
serial_results <- rep(0,N)
for(i in 1:N){
serial_results[i] <- my_function(i)
}
})
#define a function that we are going to run in parallel
my_function <- function(col_number){
#take the column sum of the matrix
col_sum <- sum(data[,col_number])
return(col_sum)
}
# Run analysis in serial
system.time({
serial_results <- rep(0,N)
for(i in 1:N){
serial_results[i] <- my_function(i)
}
})
# Run analysis in parallel
system.time({
parallel_results <- foreach(i=1:N,.combine=rbind) %dopar% {
cur_result <- my_function(i)
}
})
# Packages:
require(doMC)
require(foreach)
install.packages("doMC")
install.packages("foreach")
require(doMC)
require(foreach)
install.packages("doMC")
getwd()
install.packages("statnet")
library(statnet)
par(mfrow = c(1,1))
colors <- (1:11)
years <- 100:110
netplot <- function(year, color){
net <- as.network(get(paste("Senate_Cosponsorship_Matrix_",year, sep = "")))
plot(net, vertex.col = color)
if(color == 1){
output <- degree(net)
}else{
output <- rbind(output,degree(net))
}
Sys.sleep(.2)
return(output)
}
result <- mapply(netplot, years,colors)
apply(result,sum)
result <- mapply(netplot, years,colors)
of time. This is a very complex data management problem.
Congresses <- 11
Bills_To_Use <- 100
#' The assign() function lets us name objects usign the paste function in R.
#' This is good for batch reading in data or generating lots of data objects.
# lets begin by loading in some data:
print("Loading Raw Senate Cosponsorship Matrix Data")
for(i in 1:Congresses){
cur <- 99 + i
# read in the .csv files
data_name <- paste(cur,"_senmatrix.txt", sep = "")
temp <- read.csv(data_name, stringsAsFactors = F, header = F)
# keep first Bills_To_Use bills from each congress
temp <- temp[,1:Bills_To_Use]
#name th object
object_name <-  paste("Senate_Raw_Cosponsorship_",cur, sep = "")
#assigns the raw cosponsorship data to a named variable
assign(object_name,temp)
}
#' The get() function performs the opposite funtion of the assign function and
#' lets us get objects by their pasted name:
#' save a list of all the raw data which we will not care about after we have
#' transformed it so we can remove it later
all_objects <- ls()
cat("Transforming Raw data into Cosponsorship Matricies \n")
for(i in 1:Congresses){
cur <- 99 + i
cat(paste("Currently on Congress number: ",cur,"\n", sep = ""))
# get the current data object
object_name <-  paste("Senate_Raw_Cosponsorship_",cur, sep = "")
temp <- get(object_name)
#create a sociomatrix to populate
num_senators <- length(temp[,1])
temp_sociomatrix <- matrix(0,ncol = num_senators, nrow = num_senators)
# this is an example of nested looping
for(j in 1:length(temp[1,])){#for every bill
#find out who the bill sponsor is (coded as a 1)
for(k in 1: length(temp[,1])){ #for every Senator
if(temp[k,j] == 1){
sponsor <- k
}
}
#find all of the cosponsors
for(k in 1: length(temp[,1])){ #for every Senator
if(temp[k,j] == 2){
temp_sociomatrix[sponsor,k] <- temp_sociomatrix[sponsor,k] + 1
}
}
}
sociomat_name <- paste("Senate_Cosponsorship_Matrix_",cur, sep = "")
# assigns the cosponsorship matrix to a named variable
assign(sociomat_name,temp_sociomatrix)
}
#' remove all of the raw data -- how could we do all of this without creating
#' these objects in the first place?
rm(list = all_objects)
#' so far we have written code which could be turned into a function. A simple
#' example might be a function that counts the total number of cosponsorships in
#' a given congress.
Total_Cosponsorships <- function(cosponsorship_matrix){
total <- 0
for(i in 1:length(cosponsorship_matrix[1,])){
for(j in 1:length(cosponsorship_matrix[,1])){
total <- total + cosponsorship_matrix[j,i]
}
}
return(total)
}
#' now we have to enter the function in the console before we can use it. If you
#' are using RStudio then you will see the function pop up in your workspace.
#' try it out!
Total_Cosponsorships(Senate_Cosponsorship_Matrix_100)
#' We can use functions inside of functions as well. Note that we can set
#' default values for a function by putting an = sign next to the arguemnt name
Cosponsorships_per_Congress <- function(start = 100, end = 110){
num_cases <- end - start + 1
vector <- rep(0, times = num_cases)
for(i in 1:num_cases){
cur <- start - 1 + i
#' sometimes we want an update of where we are in the process
cat(paste("Currently on Congress Number: ", cur ,"\n", sep = ""))
#' we can also call a function from inside a function... inside a
#' function... inside a function
vector[i] <- Total_Cosponsorships(get(paste(
"Senate_Cosponsorship_Matrix_",cur, sep = "")))
}
return(vector)
}
#' try it out (note that you do not need to have any arguments because we have
#' set default values for all arguments -- this can be dangerous!)
Cosp_per_Congress <- Cosponsorships_per_Congress()
#plot our work
barplot(Cosp_per_Congress,
xlab = "Congress",
ylab = "Number of Cosponsorships",
names = c(100:110),
col = rainbow(11))
par(mfrow = c(1,1))
colors <- (1:11)
years <- 100:110
netplot <- function(year, color){
net <- as.network(get(paste("Senate_Cosponsorship_Matrix_",year, sep = "")))
plot(net, vertex.col = color)
if(color == 1){
output <- degree(net)
}else{
output <- rbind(output,degree(net))
}
Sys.sleep(.2)
return(output)
}
result <- mapply(netplot, years,colors)
apply(result,sum)
filenames <- rep("0", 10)
for (i in 100:110){
temp <- read.csv(paste(i, "_senmatrix.txt", sep=""))
append(filenames, temp)
}
filenames <- list(0)
filenames <- list(1:11)
for (i in 100:110){
temp <- read.csv(paste(i, "_senmatrix.txt", sep=""))
append(filenames, temp)
}
filenames <- list(1:11)
for (i in 100:110){
temp <- read.csv(paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, temp)
}
filenames <- list(1:11)
for (i in 100:110){
assign(paste((i, "_senmatrix.txt", sep="")))
filenames <- c(filenames, temp)
}
filenames <- list(1:11)
for (i in 100:110){
assign(paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, temp)
}
filenames <- list(1:11)
for (i in 100:110){
one.filename <- (paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, one.filename)
}
filenames <- list()
for (i in 100:110){
one.filename <- (paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, one.filename)
}
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List <- c(,temp)
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
Raw_Data_List <- list()
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List <- c(Raw_Data_List,temp)
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List <- c(Raw_Data_List,temp)
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
i <- 1
temp <- read.csv(filenames[[i]])
Raw_Data_List[[i]] <- temp
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
i <- 1
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
rm(list = ls())
filenames <- list()
for (i in 100:110){
one.filename <- (paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, one.filename)
}
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
print(i)
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
print(i)
Raw_Data_List[i] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
to create a vector of filenames.
filenames <- list()
for (i in 100:110){
one.filename <- (paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, one.filename)
}
i <- 1
temp <- read.csv(filenames[[i]])
print(i)
Raw_Data_List[[i]] <- temp
Raw_Data_List <- list()
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
ed to create a vector of filenames.
filenames <- list()
for (i in 100:110){
one.filename <- (paste(i, "_senmatrix.txt", sep=""))
filenames <- c(filenames, one.filename)
}
Raw_Data_List <- list()
Read_In_Data <- function(filenames){
#' you will want to loop over the vector of filenames and load each one in to
#' a slot in the Raw_Data_List object you create before returning it. Printing
#' out progress would be nice!
for (i in 1:length(filenames)){
temp <- read.csv(filenames[[i]])
print(i)
Raw_Data_List[[i]] <- temp
return(Raw_Data_List)
}
}
Read_In_Data(filenames)
head(Raw_Data_List)
#' get filenames
mywd <- "~/Dropbox/RA_and_Consulting_Work/ISSR_Data_Science_Summer_Summit_15/Data"
setwd(mywd)
filenames <- NULL
for(i in 100:110){
filenames <- append(filenames, paste(i,"_senmatrix.txt", sep = ""))
}
# define the function
Read_In_Data <- function(filenames){
Raw_Data_List <- vector(mode = "list", length = length(filenames))
for(i in 1:length(filenames)){
cat("Current Dataset", i,"\n")
Raw_Data_List[[i]] <- read.csv(filenames[i], stringsAsFactors = F, header = F)
}
return(Raw_Data_List)
}
head(Raw_Data_List)
