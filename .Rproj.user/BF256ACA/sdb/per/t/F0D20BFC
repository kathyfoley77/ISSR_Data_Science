{
    "contents" : "#' Exercise 2-- in this exercise you will be going for speed and clarity. You \n#' will be taking the block of code below and wrapping it into several functions\n#' and parallelizing everything to make it run faster. This assignment will be\n#' more similar to what you might actually encounter in the wild. (notice how I \n#' use the \"#'\" symbol at the beginning of each line? In RStudio this will \n#' automatically continue the block comment --- super handy!)\n\n\n#' Here is the start of the code you will be modifying. It reads in 11 years of\n#' cosponosrship data and turns it into sociomatricies suitable for network\n#' analysis. You will want to make use of parts of this block of code -- with \n#' heavy modifications -- in the exercise\n\n############################ START EXAMPLE CODE ################################\n\n# set working directory\nmywd <- \"C:/Users/kfoley/Documents/GitHub/ISSR_Data_Science\"\nsetwd(mywd)\n\n#' We are going to be looking at a dataset that comprises 11 sessions on \n#' congress and sepcifically the bills cosponsored by senators over that period\n#' of time. This is a very complex data management problem.\nCongresses <- 11\nBills_To_Use <- 100\n\n#' The assign() function lets us name objects usign the paste function in R. \n#' This is good for batch reading in data or generating lots of data objects.\n\n# lets begin by loading in some data:\nprint(\"Loading Raw Senate Cosponsorship Matrix Data\")\nfor(i in 1:Congresses){\n    cur <- 99 + i\n    \n    # read in the .csv files\n    data_name <- paste(cur,\"_senmatrix.txt\", sep = \"\")\n    temp <- read.csv(data_name, stringsAsFactors = F, header = F)\n    \n    # keep first Bills_To_Use bills from each congress\n    temp <- temp[,1:Bills_To_Use]\n    \n    #name th object\n    object_name <-  paste(\"Senate_Raw_Cosponsorship_\",cur, sep = \"\")\n    \n    #assigns the raw cosponsorship data to a named variable\n    assign(object_name,temp) \n}\n\n\n#' The get() function performs the opposite funtion of the assign function and \n#' lets us get objects by their pasted name:\n\n#' save a list of all the raw data which we will not care about after we have \n#' transformed it so we can remove it later\nall_objects <- ls()\n\ncat(\"Transforming Raw data into Cosponsorship Matricies \\n\")\nfor(i in 1:Congresses){\n    cur <- 99 + i\n    cat(paste(\"Currently on Congress number: \",cur,\"\\n\", sep = \"\"))\n    \n    # get the current data object\n    object_name <-  paste(\"Senate_Raw_Cosponsorship_\",cur, sep = \"\")\n    temp <- get(object_name)\n    \n    #create a sociomatrix to populate\n    num_senators <- length(temp[,1])\n    temp_sociomatrix <- matrix(0,ncol = num_senators, nrow = num_senators)\n    \n    # this is an example of nested looping \n    for(j in 1:length(temp[1,])){#for every bill\n        \n        #find out who the bill sponsor is (coded as a 1)\n        for(k in 1: length(temp[,1])){ #for every Senator\n            if(temp[k,j] == 1){\n                sponsor <- k\n            }  \n        }\n        \n        #find all of the cosponsors\n        for(k in 1: length(temp[,1])){ #for every Senator\n            if(temp[k,j] == 2){\n                temp_sociomatrix[k, sponsor] <- temp_sociomatrix[k, sponsor] + 1\n            } \n        }\n    }\n    \n    sociomat_name <- paste(\"Senate_Cosponsorship_Matrix_\",cur, sep = \"\")\n    # assigns the cosponsorship matrix to a named variable\n    assign(sociomat_name,temp_sociomatrix) \n   \n}\n\n#' remove all of the raw data -- how could we do all of this without creating \n#' these objects in the first place?\nrm(list = all_objects)\n\n#' so far we have written code which could be turned into a function. A simple\n#' example might be a function that counts the total number of cosponsorships in\n#' a given congress.\n\nTotal_Cosponsorships <- function(cosponsorship_matrix){\n    total <- 0\n    for(i in 1:length(cosponsorship_matrix[1,])){\n        for(j in 1:length(cosponsorship_matrix[,1])){\n            total <- total + cosponsorship_matrix[j,i]\n        }\n    }\n    return(total)\n}\n\n#' now we have to enter the function in the console before we can use it. If you\n#' are using RStudio then you will see the function pop up in your workspace.\n#' try it out!\nTotal_Cosponsorships(Senate_Cosponsorship_Matrix_100)\n\n#' We can use functions inside of functions as well. Note that we can set \n#' default values for a function by putting an = sign next to the arguemnt name\n\nCosponsorships_per_Congress <- function(start = 100, end = 110){\n    num_cases <- end - start + 1\n    vector <- rep(0, times = num_cases)\n    for(i in 1:num_cases){\n        cur <- start - 1 + i\n        #' sometimes we want an update of where we are in the process\n        cat(paste(\"Currently on Congress Number: \", cur ,\"\\n\", sep = \"\"))\n        #' we can also call a function from inside a function... inside a \n        #' function... inside a function\n        vector[i] <- Total_Cosponsorships(get(paste(\n          \"Senate_Cosponsorship_Matrix_\",cur, sep = \"\")))\n    }\n    return(vector)\n}\n\n#' try it out (note that you do not need to have any arguments because we have \n#' set default values for all arguments -- this can be dangerous!)\nCosp_per_Congress <- Cosponsorships_per_Congress()\n\n#plot our work\nbarplot(Cosp_per_Congress,\n        xlab = \"Congress\", \n        ylab = \"Number of Cosponsorships\", \n        names = c(100:110),\n        col = rainbow(11))\n\n\n#6.5 having some fun -- what does this function do? How does it work?\nlibrary(statnet)\n\npar(mfrow = c(1,1))\ncolors <- (1:11)\nyears <- 100:110\n\nnetplot <- function(year, color){\n    net <- as.network(get(paste(\"Senate_Cosponsorship_Matrix_\",year, sep = \"\")))\n    plot(net, vertex.col = color)\n    if(color == 1){\n        output <- degree(net)\n    }else{\n        output <- rbind(output,degree(net))\n    }\n    Sys.sleep(.2)\n    return(output)\n}\n\nresult <- mapply(netplot, years,colors)\n\napply(result,sum)\n\n############################ END EXAMPLE CODE ##################################\n\n#' Your Assignment: Take the code on lines 16-95 and make it faster, more \n#' flexible and less messy. You should start by filling in the helper functions\n#' outlined below, followed by the top level function which will take an \n#' arbitrary number of input files of the same format as you are working with\n#' and generate a list of sociomatricies out of them:\n#' \n\n\n# need to create a vector of filenames.\n\nfilenames <- list()\n\nfor (i in 100:110){\n  one.filename <- (paste(i, \"_senmatrix.txt\", sep=\"\"))\n    filenames <- c(filenames, one.filename)\n}\n\n\nRaw_Data_List <- list()\n\nRead_In_Data <- function(filenames){\n  #' you will want to loop over the vector of filenames and load each one in to\n  #' a slot in the Raw_Data_List object you create before returning it. Printing\n  #' out progress would be nice!\n\n   for (i in 1:length(filenames)){\n    temp <- read.csv(filenames[[i]])\n    print(i)\n    Raw_Data_List[[i]] <- temp\n  \n  return(Raw_Data_List)\n  }\n}\n\nRead_In_Data(filenames)\n\n\n\nGenerate_Sociomatrix <- function(list_index, raw_data_list, num_bills){\n  #' takes in a list index, extracts the right raw data object from the raw data\n  #' list object, iterates over a specified number of\n  #' columns (bills) and returns a square (direted) sociomatrix \n  return(Sociomatrix)\n}\n\nPreProcess_Network_Data <- function(filenames, num_bills, num_cores){\n  #' read in the data an generate an internal raw data list object. Then use\n  #' parallel processing (one of the three functions we discussed) to process\n  #' the data and return a list containing all sociomatricies. Try different\n  #' approaches and see which is fastest?\n  return(Sociomatrix_List)\n}\n\n#' Once you have a working function, try speed testing different versions with \n#' different kinds of parallelization against the stock code for different \n#' values of num_bills, num_cores and for different numbers of files to work on.\n#' You can use the following code to determine the elapsed time:\n\nsystem.time({\n  #' Your function goes here!\n})\n\n#' You may then want to stick all of your testing inside of a loop to automate \n#' it. Save your results in a dataframe and then give plotting them a try. What\n#' do you observe?\n\n\n################################################################################\n#' Answer Code Below -- Spoiler ALERT!\n################################################################################\n\n\n\n\n\n\n\n\n\n\n#' get filenames\nmywd <- \"~/Dropbox/RA_and_Consulting_Work/ISSR_Data_Science_Summer_Summit_15/Data\"\nsetwd(mywd)\nfilenames <- NULL\nfor(i in 100:110){\n  filenames <- append(filenames, paste(i,\"_senmatrix.txt\", sep = \"\"))\n}\n\n# define the function\nRead_In_Data <- function(filenames){\n  Raw_Data_List <- vector(mode = \"list\", length = length(filenames))\n  for(i in 1:length(filenames)){\n    cat(\"Current Dataset\", i,\"\\n\")\n    Raw_Data_List[[i]] <- read.csv(filenames[i], stringsAsFactors = F, header = F)\n  }\n  return(Raw_Data_List)\n}\n\n\n# define function\nGenerate_Sociomatrix <- function(list_index, raw_data_list, num_bills){\n  #' takes in a list index, extracts the right raw data object from the raw data\n  #' list object, iterates over a specified number of\n  #' columns (bills) and returns a square (direted) sociomatrix \n  temp <- raw_data_list[[list_index]]\n  #create a sociomatrix to populate\n  num_senators <- length(temp[,1])\n  Sociomatrix <- matrix(0,ncol = num_senators, nrow = num_senators)\n  # this is an example of nested looping \n  for(j in 1:num_bills){#for every bill\n    cat(\"Current Index:\",list_index,\"Bill:\",j,\"of\",length(temp[1,]),\"\\n\")\n    #find out who the bill sponsor is (coded as a 1)\n    for(k in 1: length(temp[,1])){ #for every Senator\n      if(temp[k,j] == 1){\n        sponsor <- k\n      }  \n    }\n    #find all of the cosponsors\n    for(k in 1: length(temp[,1])){ #for every Senator\n      if(temp[k,j] == 2){\n        Sociomatrix[sponsor,k] <- Sociomatrix[sponsor,k] + 1\n      } \n    }\n  }\n  return(Sociomatrix)\n}\n\nPreProcess_Network_Data <- function(filenames, num_bills, num_cores){\n  # num_bills = 2\n  # num_cores = 2\n  Raw_Data <- Read_In_Data(filenames)\n  cat(\"Processing Data into Sociomatricies... \\n\")\n  # Packages:\n  require(doMC)\n  require(foreach)\n  # Register number of cores\n  registerDoMC(num_cores)\n  # Run analysis in parallel\n  wrapper <- function(index){\n    print(index)\n    max_num_bills <- length(Raw_Data[[index]][1,])\n    if(num_bills> max_num_bills){\n      num_bills <- max_num_bills\n    }\n    result <- Generate_Sociomatrix(index,Raw_Data,num_bills)\n    return(result)\n  }\n  Sociomatrix_List <- foreach(i=1:length(filenames)) %dopar% {\n    result <- wrapper(i)\n  }\n  #' read in the data an generate an internal raw data list object. Then use\n  #' parallel processing (one of the three functions we discussed) to process\n  #' the data and return a list containing all sociomatricies. Try different\n  #' approaches and see which is fastest?\n  return(Sociomatrix_List)\n}\n\n\nsystem.time({\n  Result <- PreProcess_Network_Data(filenames,10,4)\n})\n#'    user  system elapsed \n#'  43.303   1.646  49.726\n\nsystem.time({\n  Result <- PreProcess_Network_Data(filenames,10,1)\n})\n#'    user  system elapsed \n#'  48.914   0.875  66.553 \n",
    "created" : 1433271025757.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2352898400",
    "id" : "F0D20BFC",
    "lastKnownWriteTime" : 1433274878,
    "path" : "~/GitHub/ISSR_Data_Science/scripts/Day_Two_Exercise.R",
    "project_path" : "scripts/Day_Two_Exercise.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}